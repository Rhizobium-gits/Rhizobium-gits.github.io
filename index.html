<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Tsubasa's Fun Profile</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@100;300;400;500&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Noto Sans JP', sans-serif;
      background-color: #000;
      color: #fff;
      overflow: hidden;
    }
    
    #canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
      touch-action: none;
    }
    
    .custom-cursor {
      position: fixed;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      pointer-events: none;
      z-index: 9999;
      mix-blend-mode: difference;
      transform: translate(-50%, -50%);
      transition: width 0.3s, height 0.3s;
      display: none; /* モバイルでは非表示 */
    }
    
    .cursor-dot {
      background-color: #fff;
    }
    
    .cursor-ring {
      border: 2px solid rgba(255, 255, 255, 0.5);
      width: 40px;
      height: 40px;
    }
    
    .loading-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #000;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      transition: opacity 1s ease-in-out;
    }
    
    .loading-progress {
      width: 300px;
      height: 2px;
      background: rgba(255, 255, 255, 0.1);
      margin: 20px 0;
      position: relative;
      overflow: hidden;
    }
    
    .progress-bar {
      position: absolute;
      top: 0;
      left: 0;
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #3a63ad, #5bbfc3, #3a63ad);
      background-size: 200% 100%;
      animation: gradientShift 2s linear infinite;
      transition: width 0.5s ease;
    }
    
    @keyframes gradientShift {
      0% { background-position: 0% 0; }
      100% { background-position: 200% 0; }
    }
    
    .loading-text {
      font-size: 14px;
      color: rgba(255, 255, 255, 0.6);
      letter-spacing: 2px;
      margin-top: 10px;
    }
    
    .info-panel {
      position: fixed;
      right: -400px;
      top: 0;
      width: 90%;
      max-width: 400px;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(10px);
      z-index: 100;
      padding: 30px;
      overflow-y: auto;
      transition: right 0.5s cubic-bezier(0.65, 0, 0.35, 1);
      border-left: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .info-panel.active {
      right: 0;
    }
    
    .panel-close {
      position: absolute;
      top: 20px;
      right: 20px;
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      border: 1px solid rgba(255, 255, 255, 0.2);
      color: rgba(255, 255, 255, 0.6);
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 18px;
    }
    
    .panel-close:hover {
      background: rgba(255, 255, 255, 0.1);
      color: #fff;
      transform: rotate(90deg);
    }
    
    .panel-content {
      opacity: 0;
      transform: translateY(10px);
      transition: opacity 0.5s ease, transform 0.5s ease;
      transition-delay: 0.3s;
    }
    
    .info-panel.active .panel-content {
      opacity: 1;
      transform: translateY(0);
    }
    
    h2 {
      font-size: 1.8em;
      margin-bottom: 20px;
      font-weight: 300;
      color: #fff;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      padding-bottom: 10px;
    }
    
    h3 {
      font-size: 1.3em;
      margin: 20px 0 15px 0;
      font-weight: 400;
      color: #fff;
      border-bottom: 1px dotted rgba(255, 255, 255, 0.1);
      padding-bottom: 5px;
    }
    
    p {
      margin-bottom: 15px;
      font-size: 0.95em;
      line-height: 1.6;
      color: rgba(255, 255, 255, 0.8);
    }
    
    .paper-item {
      margin-bottom: 15px;
      font-size: 0.9em;
      line-height: 1.5;
      color: rgba(255, 255, 255, 0.8);
      padding-left: 10px;
      border-left: 2px solid rgba(91, 191, 195, 0.4);
    }
    
    .paper-item a {
      color: #5bbfc3;
      text-decoration: none;
      transition: color 0.3s ease;
    }
    
    .paper-item a:hover {
      color: #ffffff;
      text-decoration: underline;
    }
    
    .help-tooltip {
      position: fixed;
      left: 20px;
      bottom: 20px;
      padding: 10px 15px;
      background: rgba(0, 0, 0, 0.7);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 20px;
      font-size: 12px;
      color: rgba(255, 255, 255, 0.6);
      z-index: 10;
      pointer-events: none;
      opacity: 0;
      transform: translateY(10px);
      transition: opacity 0.5s ease, transform 0.5s ease;
    }
    
    .help-tooltip.visible {
      opacity: 1;
      transform: translateY(0);
    }
    
    .time-display {
      position: fixed;
      top: 20px;
      left: 20px;
      font-size: 14px;
      color: rgba(255, 255, 255, 0.6);
      z-index: 10;
      font-family: monospace;
    }
    
    .node-tooltip {
      position: fixed;
      background: rgba(0, 0, 0, 0.7);
      color: #fff;
      padding: 5px 10px;
      border-radius: 4px;
      font-size: 12px;
      pointer-events: none;
      z-index: 1000;
      opacity: 0;
      transition: opacity 0.3s ease;
      text-align: center;
      transform: translate(-50%, -100%);
      margin-top: -10px;
      backdrop-filter: blur(5px);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .progress-indicator {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.7);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 20px;
      padding: 5px 15px;
      font-size: 12px;
      color: rgba(255, 255, 255, 0.8);
      z-index: 10;
    }
    
    .progress-bar-small {
      width: 100px;
      height: 3px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 3px;
      overflow: hidden;
      margin-top: 5px;
    }
    
    .progress-fill {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #3a63ad, #5bbfc3);
      transition: width 0.3s ease;
    }
    
    .next-stage-button {
      position: fixed;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255, 215, 0, 0.9);
      color: #000;
      padding: 15px 30px;
      border-radius: 50px;
      font-size: 18px;
      font-weight: 500;
      text-align: center;
      cursor: pointer;
      z-index: 1001;
      box-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
      opacity: 0;
      transition: all 0.5s ease;
      pointer-events: none;
      white-space: nowrap;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .next-stage-button.visible {
      opacity: 1;
      pointer-events: auto;
    }
    
    .next-stage-button:hover, .next-stage-button:active {
      background: rgba(255, 215, 0, 1);
      transform: translateX(-50%) scale(1.05);
      box-shadow: 0 0 40px rgba(255, 215, 0, 0.8);
    }
    
    /* Thank Youメッセージ (画面中央固定) */
    .thank-you-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 500;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.4s ease;
    }
    
    .thank-you-message {
      font-size: 60px;
      font-weight: bold;
      color: #ffdd00;
      text-align: center;
      text-shadow: 0 0 20px rgba(255, 221, 0, 0.8), 0 0 40px rgba(255, 221, 0, 0.5);
      white-space: nowrap;
      transform: scale(0);
      transition: transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      user-select: none;
    }
    
    .thank-you-container.visible {
      opacity: 1;
    }
    
    .thank-you-container.visible .thank-you-message {
      transform: scale(1);
      animation: pulse 0.6s ease-in-out 0.5s;
    }
    
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.2); }
      100% { transform: scale(1); }
    }
    
    @media (max-width: 768px) {
      .loading-progress {
        width: 80%;
        max-width: 300px;
      }
      
      h1 {
        font-size: 1.8em;
      }
      
      .help-tooltip {
        width: 80%;
        max-width: 300px;
        left: 50%;
        transform: translateX(-50%) translateY(10px);
        text-align: center;
      }
      
      .help-tooltip.visible {
        transform: translateX(-50%) translateY(0);
      }
      
      .next-stage-button {
        padding: 12px 24px;
        font-size: 16px;
        width: 80%;
        max-width: 300px;
        bottom: 50px;
      }
      
      .thank-you-message {
        font-size: 40px; /* スマホ向けにサイズ調整 */
      }
    }
  </style>
</head>
<body>
  <!-- ローディング画面 -->
  <div class="loading-screen" id="loadingScreen">
    <h1>Tsubasa's Fun Profile</h1>
    <div class="loading-progress">
      <div class="progress-bar" id="progressBar"></div>
    </div>
    <div class="loading-text" id="loadingText">3D空間を生成中...</div>
  </div>
  
  <!-- カスタムカーソル (PCのみ) -->
  <div class="custom-cursor cursor-dot"></div>
  <div class="custom-cursor cursor-ring"></div>
  
  <!-- 3Dキャンバス -->
  <canvas id="canvas"></canvas>
  
  <!-- Thank Youメッセージ (画面中央固定) -->
  <div class="thank-you-container" id="thankYouContainer">
    <div class="thank-you-message">Thank you!!</div>
  </div>
  
  <!-- 情報パネル -->
  <div class="info-panel" id="infoPanel">
    <div class="panel-close" id="panelClose">×</div>
    <div class="panel-content" id="panelContent">
      <!-- パネルの内容はJavaScriptで動的に生成 -->
    </div>
  </div>
  
  <!-- ヘルプツールチップ -->
  <div class="help-tooltip" id="helpTooltip"></div>
  
  <!-- 時間表示 -->
  <div class="time-display" id="timeDisplay"></div>
  
  <!-- ノードツールチップ -->
  <div class="node-tooltip" id="nodeTooltip"></div>
  
  <!-- 進捗インジケーター -->
  <div class="progress-indicator">
    <div>発見した情報: <span id="discoveryCount">0</span>/<span id="totalNodes">0</span></div>
    <div class="progress-bar-small">
      <div class="progress-fill" id="discoveryProgress"></div>
    </div>
  </div>
  
  <!-- 次のステージボタン -->
  <div class="next-stage-button" id="nextStageButton">次のステージに進む（Tap here）</div>

  <!-- ライブラリの読み込み -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>

  <script>
    // プロフィール情報データ
    const profileData = {
      about: {
        title: "プロフィール",
        content: `<p><strong>Nature to Tech, Tech to Nature.(2024)</strong> </p>
        <p><strong>佐藤 翼</strong> </p>
        <p>2006年生まれ、2018年ごろより研究活動を始める。宇宙移住型社会を目指し、地球生態系の再現・月コンクリート・腸内細菌叢とヒトの健康などの研究をしている。</p>
                  <p>慶應義塾大学 環境情報学部 学士課程1年。慶應義塾大学 先端生命科学研究会 腸内細菌グループ所属。東京科学大学難治疾患研究所計算システム生物学分野 技術支援員。ADvance Lab. 副所長 兼 宇宙部門リーダー。</p>
                  <p><strong>座右の銘:</strong> "やってみないとわからない / The answer is always found through action"</p>`
      },
      research: {
        title: "研究テーマ",
        content: `<p><strong>地球生態系の再現</strong><br>
                  宇宙環境での持続可能な縮小型人工生態系の構築を通して地球生態系のモデル化と再現.閉鎖環境での生態系維持に必要な要素と相互作用を解明することで,長期宇宙ミッションや宇宙コロニーでの生命維持システムの確立に貢献します.</p>
                  
                  <p><strong>月面可溶性コンクリート</strong><br>
                  月の現地資源を活用した建設材料の開発.月の表土（レゴリス）と限られた資源を用いて、耐久性のある構造物を構築するための新しい材料科学アプローチ.</p>
                  
                  <p><strong>腸内細菌叢とヒトの健康</strong><br>
                  微小重力環境が腸内微生物叢に与える影響とそれが宇宙飛行士の健康にどのように影響するかを研究しています。</p>
                  
                  <p><strong>COMING SOON ×3 </strong><br>`
                  
      },
      papers: {
        title: "論文",
        content: `<h3>Paper (peer-reviewed)</h3>
                  <div class="paper-item">
                    1. Sato, T., Abe, K., Koseki, J. <i>et al.</i> Survivability and life support in sealed mini-ecosystems with simulated planetary soils. <i>Sci Rep</i> 14, 26322 (2024). <a href="https://doi.org/10.1038/s41598-024-75328-x" target="_blank">https://doi.org/10.1038/s41598-024-75328-x</a>
                  </div>
                  
                  <h3>Preprint</h3>
                  <div class="paper-item">
                    1. Survivability and Life Support in Sealed Mini-Ecosystems with Simulated Planetary Soils Tsubasa Sato, Ko Abe, Jun Koseki, Mayumi Seto, Jun Yokoyama, Tomohiro Akashi, Masahiro Terada, Kohmei Kadowaki, Satoshi Yoshida, Yosuke Alexandre Yamashiki, Teppei Shimamura bioRxiv 2023.11.02.565408; doi: <a href="https://doi.org/10.1101/2023.11.02.565408" target="_blank">https://doi.org/10.1101/2023.11.02.565408</a>
                  </div>
                  
                  <h3>International Conference</h3>
                  <div class="paper-item">
                    1. Sato, T. 「Survivability and life support in sealed mini-ecosystems with simulated planetary soils」7th MVA Global Workshop & Symposium (MVA2023), Japan, 2023.12
                  </div>`
      },
      awards: {
        title: "受賞歴",
        content: `<p><strong>2024</strong><br>
                  - TOP100 -DOWNLOADED ARTICLES- 2024 (Scientific Reports・Nature Portfolio)</p>
                  
                  <p><strong>2023</strong><br>
                  - Encouragement Award at the Japanese Society of Plant Physiology(JSPP) (64th Annual Meeting)<br>
                  - Excellence Award at the Kyoto University Space Symposium (Kyoto University Space Unit, 16th Annual Meeting)</p>
                  
                  <p><strong>2022</strong><br>
                  - Best Poster Award at Science Castle 2022 Chugoku-Shikoku Regional Meeting (Leave a nest Inc./Science Castle 2022)<br>
                  - Silver Award at Japanese Biochemical Society (JBS) (95th Annual Meeting)</p>`
      },
      timeline: {
        title: "経歴",
        content: `<p><strong>2025</strong><br>
                  慶應義塾大学 環境情報学部<br>
                  慶應義塾大学 先端生命科学研究会 (福田グループ)<br>
                  慶應義塾大学 先端生命科学研究会 (鈴木研)<br>
                  東京科学大学 難治疾患研究所 計算システム生物学分野 (島村研) 技術支援員<br>
                  ADvance Lab. 副所長<br>
                  ADvance Lab. 宇宙部門 リーダー</p>
                  
                  <p><strong>2024</strong><br>
                  ADvance Lab. 宇宙部門 リーダー<br>
                  ADvance Lab. 大学戦略チーム</p>
                  
                  <p><strong>2023</strong><br>
                  農研機構インターンシップ修了</p>
                  
                  <p><strong>2018-2024</strong><br>
                  岡山白陵中学校・高等学校</p>`
      },
      lecture: {
        title: "講演",
        content: `<p><strong>2025</strong><br>
                  KMLx, Venture Sessions, -Resilience of People and Planet- (Leave a nest Inc.) June 2025</p>
                  
                  <p><strong>2024</strong><br>
                  KMLx in TOKYO, Academic Session, -Concept of life- (Leave a nest Inc.) May 2024</p>`
      },
      funding: {
        title: "研究費獲得",
        content: `<p><strong>2025</strong><br>
                  Advance Research Funding (Leave a Nest Co., Ltd.)</p>
                  
                  <p><strong>2024</strong><br>
                  Research Funding for ADvance Lab. First Cohort (ADvance Lab. Co., Ltd.)</p>`
      },
      links: {
        title: "リンク",
        content: `<p><a href="https://scholar.google.co.jp/citations?user=13x6x4sAAAAJ&hl=ja" target="_blank" style="color:#5bbfc3;text-decoration:none;">Google Scholar</a></p>
                  <p><a href="https://www.webofscience.com/wos/author/record/LXW-1255-2024" target="_blank" style="color:#5bbfc3;text-decoration:none;">Web of Science</a></p>`
      }
    };

    // グローバル変数の設定
    let scene, camera, renderer, controls;
    let raycaster, mouse;
    let nodes = [];
    let clock = new THREE.Clock();
    let elapsedTime = 0;
    let discoveredNodes = 0;
    let allNodes = 0;
    let isMobile = false;
    let celebrationComplete = false;
    let explosionPoint = new THREE.Vector3(0, 0, 0); // 爆発の中心点

    // DOM要素
    const cursorDot = document.querySelector('.cursor-dot');
    const cursorRing = document.querySelector('.cursor-ring');
    const loadingScreen = document.getElementById('loadingScreen');
    const progressBar = document.getElementById('progressBar');
    const loadingText = document.getElementById('loadingText');
    const infoPanel = document.getElementById('infoPanel');
    const panelContent = document.getElementById('panelContent');
    const panelClose = document.getElementById('panelClose');
    const helpTooltip = document.getElementById('helpTooltip');
    const timeDisplay = document.getElementById('timeDisplay');
    const nodeTooltip = document.getElementById('nodeTooltip');
    const discoveryCount = document.getElementById('discoveryCount');
    const totalNodes = document.getElementById('totalNodes');
    const discoveryProgress = document.getElementById('discoveryProgress');
    const nextStageButton = document.getElementById('nextStageButton');
    const thankYouContainer = document.getElementById('thankYouContainer');

    // モバイル検出
    function detectMobile() {
      return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth <= 768;
    }

    // カスタムカーソルの設定 (PCのみ)
    function setupCursor() {
      isMobile = detectMobile();
      
      if (!isMobile) {
        document.body.style.cursor = 'none';
        cursorDot.style.display = 'block';
        cursorRing.style.display = 'block';
        
        document.addEventListener('mousemove', (e) => {
          cursorDot.style.left = e.clientX + 'px';
          cursorDot.style.top = e.clientY + 'px';
          
          setTimeout(() => {
            cursorRing.style.left = e.clientX + 'px';
            cursorRing.style.top = e.clientY + 'px';
          }, 50);
        });

        document.addEventListener('mouseover', (e) => {
          if (e.target.classList.contains('interactive') || e.target.tagName === 'A' || e.target.id === 'nextStageButton' || e.target === panelClose) {
            cursorDot.style.transform = 'translate(-50%, -50%) scale(1.5)';
            cursorRing.style.transform = 'translate(-50%, -50%) scale(1.5)';
            cursorRing.style.borderColor = 'rgba(91, 191, 195, 0.8)';
          }
        });

        document.addEventListener('mouseout', (e) => {
          if (e.target.classList.contains('interactive') || e.target.tagName === 'A' || e.target.id === 'nextStageButton' || e.target === panelClose) {
            cursorDot.style.transform = 'translate(-50%, -50%) scale(1)';
            cursorRing.style.transform = 'translate(-50%, -50%) scale(1)';
            cursorRing.style.borderColor = 'rgba(255, 255, 255, 0.5)';
          }
        });
      }
      
      // モバイル向けヘルプテキストの設定
      if (isMobile) {
        helpTooltip.textContent = 'タップでノードを選択 | ドラッグで回転 | ピンチでズーム';
      } else {
        helpTooltip.textContent = 'マウスドラッグ: カメラ回転 | スクロール: ズーム | ノードをクリック: 情報表示';
      }
    }

    // Threeの初期化
    function init() {
      // シーンの作成
      scene = new THREE.Scene();
      
      // カメラの設定
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.z = 15;
      
      // レンダラーの設定
      renderer = new THREE.WebGLRenderer({
        canvas: document.getElementById('canvas'),
        antialias: true,
        alpha: true
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // パフォーマンス対策
      
      // 背景色を設定
      renderer.setClearColor(0x000000, 1);
      
      // レイキャスターとマウス位置の初期化
      raycaster = new THREE.Raycaster();
      mouse = new THREE.Vector2();
      
      // コントロールの設定
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.rotateSpeed = isMobile ? 0.7 : 0.5; // モバイルは少し速く
      controls.autoRotate = true;
      controls.autoRotateSpeed = 0.5;
      controls.enableZoom = true;
      controls.zoomSpeed = 0.8;
      controls.minDistance = 5;
      controls.maxDistance = 30;
      
      // 光源の追加
      const ambientLight = new THREE.AmbientLight(0x404040, 1);
      scene.add(ambientLight);
      
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
      directionalLight.position.set(1, 1, 1);
      scene.add(directionalLight);
      
      const pointLight = new THREE.PointLight(0x5bbfc3, 1, 50);
      pointLight.position.set(0, 0, 0);
      scene.add(pointLight);
      
      // 背景の星空を作成
      createStars();
      
      // 情報ノードの作成
      createInfoNodes();
      
      // 接続線の作成
      createConnections();
      
      // イベントリスナーの設定
      window.addEventListener('resize', onWindowResize);
      window.addEventListener('mousemove', onMouseMove);
      window.addEventListener('click', onClick);
      
      // モバイル向けタッチイベント
      if (isMobile) {
        window.addEventListener('touchstart', onTouchStart);
        window.addEventListener('touchmove', onTouchMove);
        window.addEventListener('touchend', onTouchEnd);
      }
      
      // 次のステージボタンの設定
      nextStageButton.addEventListener('click', () => {
        window.location.href = 'https://tsubasato.weebly.com';
      });
      
      // ヘルプツールチップを表示
      setTimeout(() => {
        helpTooltip.classList.add('visible');
        setTimeout(() => {
          helpTooltip.classList.remove('visible');
        }, 6000);
      }, 3000);
      
      // ノード総数を表示
      totalNodes.textContent = allNodes;
      updateDiscoveryProgress();
      
      // 初回のアニメーションフレーム
      animate();
    }

    // 星空の作成
    function createStars() {
      const starsGeometry = new THREE.BufferGeometry();
      const starsMaterial = new THREE.PointsMaterial({
        color: 0xffffff,
        size: 0.5,
        transparent: true,
        opacity: 0.8,
        sizeAttenuation: true
      });
      
      const starsVertices = [];
      for (let i = 0; i < 5000; i++) {
        const x = (Math.random() - 0.5) * 2000;
        const y = (Math.random() - 0.5) * 2000;
        const z = (Math.random() - 0.5) * 2000;
        starsVertices.push(x, y, z);
      }
      
      starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
      const stars = new THREE.Points(starsGeometry, starsMaterial);
      scene.add(stars);
    }

    // 情報ノードの作成
    function createInfoNodes() {
      const categories = Object.keys(profileData);
      allNodes = categories.length;
      
      // 球の配置を螺旋状に計算
      for (let i = 0; i < categories.length; i++) {
        const phi = Math.acos(-1 + (2 * i) / categories.length);
        const theta = Math.sqrt(categories.length * Math.PI) * phi;
        
        const x = 8 * Math.cos(theta) * Math.sin(phi);
        const y = 8 * Math.sin(theta) * Math.sin(phi);
        const z = 8 * Math.cos(phi);
        
        createInfoNode(x, y, z, categories[i], i);
      }
    }

    // 個別のノードを作成
    function createInfoNode(x, y, z, category, index) {
      // ノードの基本形状
      const geometry = new THREE.SphereGeometry(0.5, 32, 32);
      
      // グロー効果のためのシェーダーマテリアル
      const material = new THREE.ShaderMaterial({
        uniforms: {
          time: { value: 0 },
          color: { value: new THREE.Color(0x5bbfc3) },
          discovered: { value: 0.0 }
        },
        vertexShader: `
          varying vec3 vNormal;
          varying vec2 vUv;
          void main() {
            vNormal = normalize(normalMatrix * normal);
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          uniform float time;
          uniform vec3 color;
          uniform float discovered;
          varying vec3 vNormal;
          varying vec2 vUv;
          void main() {
            float pulse = 0.5 + 0.5 * sin(time * 2.0);
            float intensity = pow(0.7 - dot(vNormal, vec3(0, 0, 1.0)), 2.0);
            vec3 glow = color * (intensity + 0.3) * (pulse * 0.5 + 0.5);
            
            // ディスカバリー状態によってカラーを変更
            vec3 finalColor = mix(glow, vec3(1.0, 1.0, 1.0), discovered);
            gl_FragColor = vec4(finalColor, 1.0);
          }
        `,
        transparent: true
      });
      
      const node = new THREE.Mesh(geometry, material);
      node.position.set(x, y, z);
      node.userData = {
        category: category,
        discovered: false,
        pulseSpeed: 0.5 + Math.random() * 1.5,
        originalPosition: new THREE.Vector3(x, y, z),
        amplitude: 0.2 + Math.random() * 0.3,
        index: index
      };
      
      // 時間差でノードを配置
      node.scale.set(0, 0, 0);
      setTimeout(() => {
        gsap.to(node.scale, {
          x: 1,
          y: 1,
          z: 1,
          duration: 1.5,
          ease: "elastic.out(1, 0.3)",
          delay: index * 0.1
        });
      }, 1000);
      
      scene.add(node);
      nodes.push(node);
    }

    // ノード間の接続線を作成
    function createConnections() {
      for (let i = 0; i < nodes.length; i++) {
        for (let j = i + 1; j < nodes.length; j++) {
          if (Math.random() > 0.7) continue; // 70%の確率で接続をスキップ
          
          const startPoint = nodes[i].position;
          const endPoint = nodes[j].position;
          
          const points = [];
          points.push(startPoint);
          points.push(endPoint);
          
          const geometry = new THREE.BufferGeometry().setFromPoints(points);
          const material = new THREE.LineBasicMaterial({
            color: 0x2a3b4c,
            transparent: true,
            opacity: 0.3
          });
          
          const line = new THREE.Line(geometry, material);
          line.userData = {
            startNodeIndex: i,
            endNodeIndex: j
          };
          
          scene.add(line);
        }
      }
    }

    // ウィンドウリサイズ時の処理
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      
      // モバイル検出を更新
      isMobile = detectMobile();
    }

    // マウス移動時の処理 (PC用)
    function onMouseMove(event) {
      // モバイルの場合はスキップ
      if (isMobile) return;
      
      // マウス位置の正規化（-1から1の範囲）
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
      
      updateRaycaster(event.clientX, event.clientY);
    }

    // タッチ開始時の処理 (モバイル用)
    function onTouchStart(event) {
      // シングルタッチのみ処理
      if (event.touches.length === 1) {
        const touch = event.touches[0];
        updateRaycaster(touch.clientX, touch.clientY);
      }
    }

    // タッチ移動時の処理 (モバイル用)
    function onTouchMove(event) {
      if (event.touches.length === 1) {
        event.preventDefault(); // 画面スクロールを防止
      }
    }

    // タッチ終了時の処理 (モバイル用)
    function onTouchEnd(event) {
      if (event.changedTouches.length === 1) {
        const touch = event.changedTouches[0];
        updateRaycaster(touch.clientX, touch.clientY);
        
        // ノードとの交差をチェック
        const intersects = raycaster.intersectObjects(nodes);
        if (intersects.length > 0) {
          handleNodeClick(intersects[0].object);
        }
      }
    }

    // レイキャスター更新とホバー効果 (PC/モバイル共通)
    function updateRaycaster(clientX, clientY) {
      // マウス/タッチ位置の正規化（-1から1の範囲）
      mouse.x = (clientX / window.innerWidth) * 2 - 1;
      mouse.y = - (clientY / window.innerHeight) * 2 + 1;
      
      // レイキャスターを更新
      raycaster.setFromCamera(mouse, camera);
      
      // ノードとの交差をチェック
      const intersects = raycaster.intersectObjects(nodes);
      
      // カーソルスタイルの更新
      if (intersects.length > 0) {
        if (!isMobile) {
          document.body.style.cursor = 'pointer';
          cursorDot.style.transform = 'translate(-50%, -50%) scale(1.5)';
          cursorRing.style.transform = 'translate(-50%, -50%) scale(1.5)';
          cursorRing.style.borderColor = 'rgba(91, 191, 195, 0.8)';
        }
        
        // ツールチップの表示
        const node = intersects[0].object;
        const category = node.userData.category;
        const data = profileData[category];
        
        nodeTooltip.textContent = data.title;
        nodeTooltip.style.opacity = '1';
        nodeTooltip.style.left = clientX + 'px';
        nodeTooltip.style.top = clientY + 'px';
        
      } else {
        if (!isMobile) {
          document.body.style.cursor = 'auto';
          cursorDot.style.transform = 'translate(-50%, -50%) scale(1)';
          cursorRing.style.transform = 'translate(-50%, -50%) scale(1)';
          cursorRing.style.borderColor = 'rgba(255, 255, 255, 0.5)';
        }
        
        // ツールチップを非表示
        nodeTooltip.style.opacity = '0';
      }
    }

    // クリック時の処理 (PC用)
    function onClick(event) {
      // モバイルの場合はスキップ
      if (isMobile) return;
      
      // レイキャスターを更新
      raycaster.setFromCamera(mouse, camera);
      
      // ノードとの交差をチェック
      const intersects = raycaster.intersectObjects(nodes);
      
      if (intersects.length > 0) {
        handleNodeClick(intersects[0].object);
      }
    }

    // ノードクリック/タップ処理 (PC/モバイル共通)
    function handleNodeClick(node) {
      const category = node.userData.category;
      const data = profileData[category];
      
      // ノードを発見済みにマーク
      if (!node.userData.discovered) {
        node.userData.discovered = true;
        node.material.uniforms.discovered.value = 1.0;
        
        // 発見エフェクト（パルス）
        gsap.to(node.scale, {
          x: 1.5,
          y: 1.5,
          z: 1.5,
          duration: 0.3,
          yoyo: true,
          repeat: 1
        });
        
        discoveredNodes++;
        updateDiscoveryProgress();
      }
      
      // パネルに情報を表示
      showInfoPanel(data.title, data.content);
      
      // カメラをノードに向ける
      gsap.to(controls.target, {
        x: node.position.x,
        y: node.position.y,
        z: node.position.z,
        duration: 1,
        ease: "power2.out",
        onUpdate: function() {
          controls.update();
        }
      });
    }

    // 情報パネルの表示
    function showInfoPanel(title, content) {
      panelContent.innerHTML = `<h2>${title}</h2>${content}`;
      infoPanel.classList.add('active');
    }

    // 発見進捗の更新
    function updateDiscoveryProgress() {
      discoveryCount.textContent = discoveredNodes;
      const percentage = (discoveredNodes / allNodes) * 100;
      discoveryProgress.style.width = percentage + '%';
      
      // すべて発見した場合の特別エフェクト
      if (discoveredNodes === allNodes && !celebrationComplete) {
        // パネルを閉じる
        infoPanel.classList.remove('active');
        
        // お祝いエフェクト
        createCelebrationEffect();
      }
    }

    // すべて発見した時のお祝いエフェクト (最終版)
    function createCelebrationEffect() {
      celebrationComplete = true;
      
      // コントロールを一時的に無効化
      controls.enabled = false;
      
      // 1. すべてのノードを中央に集める - さらに短縮
      const timeline = gsap.timeline();
      
      // 中心点を設定（少し下方向に設定してカメラが見下ろす感じになるように）
      explosionPoint = new THREE.Vector3(0, -1, 0);
      
      // カメラが爆発点を見るように位置調整 - 速度アップ
      timeline.to(camera.position, {
        x: 0,
        y: 5, // 少し上から見下ろす
        z: 12,
        duration: 0.8, // 1.2→0.8に短縮
        ease: "power2.inOut"
      });
      
      timeline.to(controls.target, {
        x: explosionPoint.x,
        y: explosionPoint.y,
        z: explosionPoint.z,
        duration: 0.4, // 0.8→0.4に短縮
        ease: "power2.inOut",
        onUpdate: function() {
          controls.update();
        }
      }, "-=0.8");
      
      // ノードを中央に集める - 大幅に速度アップ
      nodes.forEach((node, index) => {
        timeline.to(node.position, {
          x: explosionPoint.x,
          y: explosionPoint.y,
          z: explosionPoint.z,
          duration: 0.5, // 0.8→0.5に短縮
          ease: "power3.inOut",
          delay: index * 0.02 // 0.04→0.02に短縮
        }, "-=0.5");
        
        // 色を黄色に変更
        timeline.to(node.material.uniforms.color.value, {
          r: 1,
          g: 0.8,
          b: 0,
          duration: 0.3 // 0.6→0.3に短縮
        }, "-=0.5");
      });
      
      // 2. 弾ける直前にカメラをアップ
      timeline.to(camera.position, {
        x: 0,
        y: 3, // より直近に
        z: 8,
        duration: 0.3, // 0.5→0.3に短縮
        ease: "power1.in",
        onComplete: function() {
          // カメラが向いていることを確認
          camera.lookAt(explosionPoint);
        }
      });
      
      // 3. 弾けるエフェクト
      timeline.to({}, {
        duration: 0.1,
        onComplete: function() {
          // ノードをいったん非表示
          nodes.forEach(node => {
            node.visible = false;
          });
          
          // 爆発パーティクルの作成 - 超強化版
          createExplosionParticles();
          
          // "Thank you!!" テキストの表示 - HTML/CSS版
          setTimeout(() => {
            showThankYouMessage();
          }, 100); // 時間短縮
        }
      });
      
      // 4. "Thank you!!" テキスト表示中
      timeline.to({}, {
        duration: 2.5, // 表示時間
        onComplete: function() {
          // ノードを再配置
          randomizeNodes();
          
          // Thank youメッセージを非表示
          hideThankYouMessage();
          
          // 通常のカメラ位置に戻す
          gsap.to(camera.position, {
            x: 0,
            y: 0,
            z: 15,
            duration: 1.2, // 1.5→1.2に短縮
            ease: "power2.inOut"
          });
          
          gsap.to(controls.target, {
            x: 0,
            y: 0,
            z: 0,
            duration: 1.2, // 1.5→1.2に短縮
            ease: "power2.inOut",
            onUpdate: function() {
              controls.update();
            }
          });
        }
      });
      
      // 5. "次のステージに進む" ボタンを表示
      timeline.to({}, {
        duration: 0.6, // 0.8→0.6に短縮
        onComplete: function() {
          // ボタンの表示
          nextStageButton.classList.add('visible');
          
          // コントロールを再度有効化
          controls.enabled = true;
          controls.autoRotate = true;
          controls.autoRotateSpeed = 0.5;
        }
      });
    }

    // Thank Youメッセージの表示 (HTML/CSS版)
    function showThankYouMessage() {
      thankYouContainer.classList.add('visible');
    }
    
    // Thank Youメッセージの非表示
    function hideThankYouMessage() {
      thankYouContainer.classList.remove('visible');
    }

    // 爆発パーティクル生成 (超強化版)
    function createExplosionParticles() {
      const particlesCount = 700; // 400→700にさらに増加
      const particlesGeometry = new THREE.BufferGeometry();
      const particlesMaterial = new THREE.PointsMaterial({
        color: 0xffdd00,
        size: 0.6, // 0.4→0.6にさらに大きく
        transparent: true,
        opacity: 1,
        sizeAttenuation: true
      });
      
      const positions = [];
      const velocities = [];
      
      for (let i = 0; i < particlesCount; i++) {
        // 初期位置は爆発点
        positions.push(explosionPoint.x, explosionPoint.y, explosionPoint.z);
        
        // ランダムな方向への速度
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.random() * Math.PI;
        const speed = 6 + Math.random() * 10; // 4-10→6-16にさらに速度アップ
        
        const vx = Math.sin(phi) * Math.cos(theta) * speed;
        const vy = Math.sin(phi) * Math.sin(theta) * speed;
        const vz = Math.cos(phi) * speed;
        
        velocities.push(vx, vy, vz);
      }
      
      particlesGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      const particles = new THREE.Points(particlesGeometry, particlesMaterial);
      particles.userData.velocities = velocities;
      particles.userData.animationStart = elapsedTime;
      
      scene.add(particles);
      
      // 追加：きらめきエフェクト用の小さなパーティクル
      const sparklesCount = 300; // 200→300に増加
      const sparklesGeometry = new THREE.BufferGeometry();
      const sparklesMaterial = new THREE.PointsMaterial({
        color: 0xffffff,
        size: 0.3, // 0.2→0.3に大きく
        transparent: true,
        opacity: 0.8,
        sizeAttenuation: true
      });
      
      const sparklePositions = [];
      const sparkleVelocities = [];
      
      for (let i = 0; i < sparklesCount; i++) {
        // 初期位置は爆発点
        sparklePositions.push(explosionPoint.x, explosionPoint.y, explosionPoint.z);
        
        // ランダムな方向への速度
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.random() * Math.PI;
        const speed = 5 + Math.random() * 8; // 3-8→5-13に速度アップ
        
        const vx = Math.sin(phi) * Math.cos(theta) * speed;
        const vy = Math.sin(phi) * Math.sin(theta) * speed;
        const vz = Math.cos(phi) * speed;
        
        sparkleVelocities.push(vx, vy, vz);
      }
      
      sparklesGeometry.setAttribute('position', new THREE.Float32BufferAttribute(sparklePositions, 3));
      const sparkles = new THREE.Points(sparklesGeometry, sparklesMaterial);
      sparkles.userData.velocities = sparkleVelocities;
      sparkles.userData.animationStart = elapsedTime;
      
      scene.add(sparkles);
      
      // 追加：大きな光球エフェクト
      const glowSphereGeometry = new THREE.SphereGeometry(0.5, 32, 32);
      const glowSphereMaterial = new THREE.MeshBasicMaterial({
        color: 0xffdd00,
        transparent: true,
        opacity: 0.7
      });
      const glowSphere = new THREE.Mesh(glowSphereGeometry, glowSphereMaterial);
      glowSphere.position.copy(explosionPoint);
      scene.add(glowSphere);
      
      // 光球のアニメーション
      gsap.to(glowSphere.scale, {
        x: 50,
        y: 50,
        z: 50,
        duration: 1,
        ease: "power2.out",
        onComplete: () => {
          // 徐々に消す
          gsap.to(glowSphereMaterial, {
            opacity: 0,
            duration: 1.5,
            onComplete: () => {
              scene.remove(glowSphere);
            }
          });
        }
      });
      
      // パーティクルアニメーションを管理
      const animateParticles = () => {
        const positions = particles.geometry.attributes.position.array;
        const velocities = particles.userData.velocities;
        const animationDuration = 3.0; // 2.5→3.0に延長
        const timeSinceStart = elapsedTime - particles.userData.animationStart;
        
        if (timeSinceStart > animationDuration) {
          // アニメーション終了したらパーティクルを削除
          scene.remove(particles);
          scene.remove(sparkles);
          return;
        }
        
        // パーティクルの位置を更新
        for (let i = 0; i < positions.length; i += 3) {
          positions[i] += velocities[i] * 0.04; // 0.03→0.04に速度アップ
          positions[i + 1] += velocities[i + 1] * 0.04;
          positions[i + 2] += velocities[i + 2] * 0.04;
          
          // 時間経過で速度を落とす - より自然な動き
          velocities[i] *= 0.985;
          velocities[i + 1] *= 0.985;
          velocities[i + 2] *= 0.985;
        }
        
        // スパークルも更新
        const sparklePositions = sparkles.geometry.attributes.position.array;
        const sparkleVelocities = sparkles.userData.velocities;
        
        for (let i = 0; i < sparklePositions.length; i += 3) {
          sparklePositions[i] += sparkleVelocities[i] * 0.05;
          sparklePositions[i + 1] += sparkleVelocities[i + 1] * 0.05;
          sparklePositions[i + 2] += sparkleVelocities[i + 2] * 0.05;
          
          sparkleVelocities[i] *= 0.98;
          sparkleVelocities[i + 1] *= 0.98;
          sparkleVelocities[i + 2] *= 0.98;
        }
        
        // 透明度の更新
        const fadeStartTime = animationDuration * 0.6; // 60%経過後に徐々に消える
        if (timeSinceStart > fadeStartTime) {
          const fade = 1 - ((timeSinceStart - fadeStartTime) / (animationDuration - fadeStartTime));
          particlesMaterial.opacity = fade;
          sparklesMaterial.opacity = fade * 0.8;
        }
        
        particles.geometry.attributes.position.needsUpdate = true;
        sparkles.geometry.attributes.position.needsUpdate = true;
        
        // 次のフレームでも継続
        requestAnimationFrame(animateParticles);
      };
      
      // アニメーション開始
      animateParticles();
    }

    // ノードのランダム再配置
    function randomizeNodes() {
      nodes.forEach((node, index) => {
        // ランダムな位置を生成
        const radius = 8;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.random() * Math.PI;
        
        const x = radius * Math.sin(phi) * Math.cos(theta);
        const y = radius * Math.sin(phi) * Math.sin(theta);
        const z = radius * Math.cos(phi);
        
        // 新しい位置を保存
        node.userData.originalPosition = new THREE.Vector3(x, y, z);
        
        // ノードを再表示
        node.visible = true;
        
        // 新しい位置にアニメーション
        gsap.fromTo(node.position, 
          { x: explosionPoint.x, y: explosionPoint.y, z: explosionPoint.z },
          { 
            x: x, 
            y: y, 
            z: z, 
            duration: 1.5,
            delay: index * 0.04, // 0.06→0.04に短縮
            ease: "elastic.out(1, 0.3)"
          }
        );
      });
    }

    // アニメーションループ
    function animate() {
      requestAnimationFrame(animate);
      
      // 経過時間の更新
      elapsedTime = clock.getElapsedTime();
      
      // コントロールの更新
      controls.update();
      
      // 時間表示の更新
      updateTimeDisplay();
      
      // ノードのアニメーション
      animateNodes();
      
      // レンダリング
      renderer.render(scene, camera);
    }

    // 時間表示の更新
    function updateTimeDisplay() {
      const date = new Date();
      const timeString = date.toLocaleTimeString();
      timeDisplay.textContent = `${timeString} | 経過時間: ${Math.floor(elapsedTime)}秒`;
    }

    // ノードのアニメーション
    function animateNodes() {
      nodes.forEach(node => {
        if (!node.visible) return;
        
        // 時間に基づく位置の変動
        const pulseSpeed = node.userData.pulseSpeed;
        const amplitude = node.userData.amplitude;
        const originalPos = node.userData.originalPosition;
        
        node.position.x = originalPos.x + Math.sin(elapsedTime * pulseSpeed) * amplitude;
        node.position.y = originalPos.y + Math.cos(elapsedTime * pulseSpeed * 0.7) * amplitude;
        node.position.z = originalPos.z + Math.sin(elapsedTime * pulseSpeed * 0.5) * amplitude;
        
        // シェーダーの時間更新
        node.material.uniforms.time.value = elapsedTime;
      });
    }

    // ローディング処理
    function simulateLoading() {
      let progress = 0;
      const interval = setInterval(() => {
        progress += Math.random() * 10;
        if (progress >= 100) {
          progress = 100;
          clearInterval(interval);
          
          // ローディング完了処理
          loadingText.textContent = 'ロード完了 - 3D空間に入ります...';
          
          setTimeout(() => {
            loadingScreen.style.opacity = '0';
            setTimeout(() => {
              loadingScreen.style.display = 'none';
              
              // カーソルとイベントの設定
              setupCursor();
              
              // Three.js の初期化
              init();
            }, 1000);
          }, 500);
        }
        
        // プログレスバーの更新
        progressBar.style.width = progress + '%';
        
        // ローディングメッセージの更新
        if (progress < 30) {
          loadingText.textContent = '3D空間を生成中...';
        } else if (progress < 60) {
          loadingText.textContent = '情報ノードを配置中...';
        } else if (progress < 90) {
          loadingText.textContent = '接続を構築中...';
        } else {
          loadingText.textContent = '最終調整中...';
        }
      }, 200);
    }

    // パネル閉じるボタンの設定
    panelClose.addEventListener('click', () => {
      infoPanel.classList.remove('active');
    });

    // ページ読み込み時の処理
    window.onload = function() {
      // ローディングシミュレーション開始
      simulateLoading();
    };
  </script>
</body>
</html>
